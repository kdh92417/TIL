# 클린 아키텍처

> 프로그래머인 `로버트 C. 마틴` 이 처음에 언급한 개념

- 좋은 아키텍처는 시스템을 **쉽게(이해하고, 개발하며, 유지보수하고, 배포)** 할 수 있게 한다.
- 아키텍처는 시스템의 동작 여부 자체와는 거의 관련이 없다.
- 아키텍처는 소프트웨어를 **유연하고** **부드럽게** **구조화** 한다.
- 좋은 아키텍트는 시스템의 **핵심적인 요소(정책)를 식별** 하고, 동시에 `세부사항`은 이 정책에 무관하게 만들 수 있는 형태로 시스템 구축
- 좋은 아키텍트는 **세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향** 으로 정책을 설계

<br>

### 위의 내용을 정리 하자면

1. 세부사항(DB, 프레임워크 등..)이 정책(업무 규칙)에 영향을 주면 안된다.
2. 계층별로 관심사를 명확하게 분리하여 변경이 필요할 때 영향을 주는 부분을 최소화
3. 내부 계층이 외부 계층을 의존하지 않아야 한다.(의존성 흐름은 바깥에서 안쪽)

<br>

## 클린 아키텍처의 구조

[이미지 집어넣어야됨 ](클린 아키텍처 이미지)


### 엔티티

- 핵심 업무 규칙을 캡슐화
- 메서드를 가지는 객체거나 일련의 데이터 구조와 함수의 집합
- 가장 변하지 않고, 외부로부터 영향을 받지 않음

### 유스 케이스

- 애플리케이션에 특화된 업무 규칙을 포함 ex) 비즈니스 로직
- 시스템의 모든 유스케이스를 캡슐화하고 구현
- 엔티티로 들어오고 나가는 데이터 흐름을 조정 및 조작

### 인터페이스 어댑터

- 일련의 어댑터들로 구성
- 어뎁터는 데이터를(유스케이스와 엔티티에 가장 편리한 형식) **<->** 외부(데이터베이스 또는 웹 같은 외부 에이전시에 가장 편리한 형식)으로 변환
- `컨트롤러(Controller)`, `프레젠터(Presenter)`, `게이트웨이(Gateway)` 등이 여기에 속함.

### 프레임워크와 드라이버

- 시스템의 핵심 업무와 관련 없는 세부사항 -> 언제든 교체 가능
- 프레임워크, DB, Web Server 등이 속함

<br>

### 결국

- 클린 아키텍트의 안쪽 영역으로 갈수록 추상화와 정책의 수준이 높아짐 -> 고수준
- 클린 아키텍트의 바깥쪽 영역으로 갈수록 세부사항으로 구성 -> 저수준

<br>

## 의존 방향 규칙

- 저수준에서 고수준으로 의존방향이 흘러야됨
- 안쪽원은 바깥쪽 원을 알지 못해야됨

### 의존성 역전

그림!!

> 실제로는 고수준(비즈니스 로직)에서 저수준(DB)을 의존 -> 의존성 역전 원칙 위반
>
> 그래서 추상화된 인터페이스를 고수준(비지니스 로직)에 두고 인터페이스를 사용
>
> 저수준에서는 고수준의 인터페이스를 상속받는 객체를 구현 -> `의존성 원칙` 지킴